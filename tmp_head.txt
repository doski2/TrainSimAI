from __future__ import annotations

import os
import sys
import time
from typing import Any, Dict, Iterable, Iterator, List
import platform
from pathlib import Path
import re


def _ensure_raildriver_on_path() -> None:
    """
    Añade el paquete local `py-raildriver-master` al sys.path si existe
    junto al repo, para poder `import raildriver` sin instalación previa.
    """
    here = Path(__file__).resolve().parent
    candidate = here.parent / "py-raildriver-master"
    if candidate.exists():
        sys.path.insert(0, str(candidate))


_ensure_raildriver_on_path()

# Importa RailDriver y Listener del paquete local
USE_FAKE = False
try:
    from raildriver import RailDriver  # type: ignore  # noqa: E402
    from raildriver.events import Listener  # type: ignore  # noqa: E402
except Exception:
    # Si no está instalado, o si se fuerza por env → usa backend simulado
    USE_FAKE = True
if (not USE_FAKE):
    import os as _os
    if _os.environ.get("TSC_FAKE_RD") == "1":
        USE_FAKE = True
if USE_FAKE:
    from ingestion.rd_fake import FakeRailDriver as RailDriver  # type: ignore  # noqa: E402
    from ingestion.rd_fake import FakeListener as Listener      # type: ignore  # noqa: E402


# Claves especiales disponibles en Listener (no se suscriben; se evalúan siempre)
SPECIAL_KEYS: List[str] = list(Listener.special_fields.keys())  # type: ignore[attr-defined]


def _locate_raildriver_dll() -> str | None:
    """Selecciona la DLL que coincide con la arquitectura de Python.

    - En Python de 64 bits, preferir 'RailDriver64.dll'.
    - En Python de 32 bits, preferir 'RailDriver.dll'.
    - Busca rutas típicas de Steam; permitir sobreescritura via env RAILWORKS_PLUGINS.
    """
    wants_64 = platform.architecture()[0] == "64bit"
    candidates: list[Path] = []
    # Sobrescritura del usuario
    env_plugins = os.environ.get("RAILWORKS_PLUGINS")
    if env_plugins:
        base = Path(env_plugins)
        candidates += [base / "RailDriver64.dll", base / "RailDriver.dll"]
    # Rutas comunes de Steam
    common_bases = [
        Path(os.environ.get("PROGRAMFILES(X86)", r"C:\\Program Files (x86)"))
        / "Steam" / "steamapps" / "common" / "RailWorks" / "plugins",
        Path(os.environ.get("PROGRAMFILES", r"C:\\Program Files"))
        / "Steam" / "steamapps" / "common" / "RailWorks" / "plugins",
    ]
    # Intentar SteamPath del registro, si está disponible
    try:
        import winreg  # type: ignore

        key = winreg.OpenKey(winreg.HKEY_CURRENT_USER, r"Software\Valve\Steam")
        steam_path, _ = winreg.QueryValueEx(key, "SteamPath")
        reg_base = Path(steam_path) / "steamapps" / "common" / "RailWorks" / "plugins"
        common_bases.insert(0, reg_base)
    except Exception:
        pass
    for base in common_bases:
        candidates += [base / "RailDriver64.dll", base / "RailDriver.dll"]
    # Elegir la mejor coincidencia
    existing = [p for p in candidates if p.exists()]
    if not existing:
        return None
    if wants_64:
        for p in existing:
            if p.name.lower() == "raildriver64.dll":
                return str(p)
    # Alternativa: 32 bits o la primera encontrada
    return str(existing[0])


class RDClient:
    """
    Wrapper de py-raildriver con utilidades de lectura puntual y streaming.

    - Usa `Listener` para obtener snapshot consistente de controles + especiales.
    - Expone utilidades para obtener un subconjunto habitual de controles.
    """

    def __init__(self, poll_dt: float = 0.2, poll_hz: float | None = None) -> None:
        if poll_hz and poll_hz > 0:
            self.poll_dt = 1.0 / float(poll_hz)
        else:
            self.poll_dt = float(poll_dt)
        # Seleccionar la DLL adecuada para evitar WinError 193 (arquitecturas distintas)
        if USE_FAKE:
            # Alias RailDriver apunta al FakeRailDriver cuando USE_FAKE=True
            self.rd = RailDriver()
        else:
            dll_path = _locate_raildriver_dll()
            self.rd = RailDriver(dll_location=dll_path) if dll_path else RailDriver()
        # Necesario para intercambiar datos con TS
        try:
            self.rd.set_rail_driver_connected(True)
        except Exception:
            # Versiones antiguas ignoran el parámetro; continúamos.
            pass

        # Índices cacheados por nombre para lecturas directas cuando conviene
        self.ctrl_index_by_name: Dict[str, int] = {
            name: idx for idx, name in self.rd.get_controller_list()
        }

        # Listener para cambios y snapshots unificados
        self.listener = Listener(self.rd, interval=self.poll_dt)
        # Cache de la última geo conocida para rellenar huecos momentáneos
        self._last_geo: Dict[str, Any] = {"lat": None, "lon": None, "heading": None, "gradient": None}
        # Suscribir todos los controles disponibles (las especiales se evalúan siempre)
        try:
            self.listener.subscribe(list(self.ctrl_index_by_name.keys()))
        except Exception:
            # Si cambia de locomotora y hay controles ausentes, se puede re-suscribir más tarde
            pass

    # --- Lectura mediante iteración única del listener ---
    def _snapshot(self) -> Dict[str, Any]:
        """Fuerza una iteración del listener y devuelve una copia del estado actual."""
        # No arrancamos hilo; usamos una iteración síncrona
        self.listener._main_iteration()  # type: ignore[attr-defined]
        cd = getattr(self.listener, "current_data", None)
        return dict(cd) if cd else {}

    # --- Lecturas puntuales ---
    def read_specials(self) -> Dict[str, Any]:
        # py‑raildriver expone helpers; aquí usamos listener snapshot para unificar
        snap = self._snapshot()
        out: Dict[str, Any] = {}
        # LocoName → [Provider, Product, Engine]
        if "!LocoName" in snap:
            loco = snap["!LocoName"] or []
            if isinstance(loco, (list, tuple)) and len(loco) >= 3:
                out.update({
                    "provider": loco[0],
                    "product": loco[1],
                    "engine": loco[2],
                })
        # Coordenadas/tiempo/rumbo/pendiente…
        coords = snap.get("!Coordinates")
        if coords and isinstance(coords, (list, tuple)) and len(coords) >= 2:
            out["lat"], out["lon"] = float(coords[0]), float(coords[1])
        else:
            # Fallback directo a RailDriver si el snapshot no trae coordenadas
            try:
                c2 = self.rd.get_current_coordinates()
                if isinstance(c2, (list, tuple)) and len(c2) >= 2:
                    out["lat"], out["lon"] = float(c2[0]), float(c2[1])
            except Exception:
                pass
        # Heading en la DLL a veces llega en radianes (~0..6.28). Añade grados también.
        if "!Heading" in snap:
            try:
                hdg = float(snap["!Heading"])
            except Exception:
                hdg = snap["!Heading"]
            out["heading"] = hdg
        elif "heading" not in out:
            try:
                h = float(self.rd.get_current_heading())
                out["heading"] = h
            except Exception:
                pass
        if "heading" in out and out["heading"] is not None:
            try:
                _hdg = float(out["heading"])
                if -7.0 <= _hdg <= 7.0:  # parece radianes
                    out["heading_deg"] = (_hdg * 180.0 / 3.141592653589793) % 360.0
                else:
                    out["heading_deg"] = _hdg % 360.0
            except Exception:
                pass
        if "!Gradient" in snap:
            out["gradient"] = snap["!Gradient"]
        elif "gradient" not in out:
            try:
                g = self.rd.get_current_gradient()
                out["gradient"] = g
            except Exception:
                pass
        if "!FuelLevel" in snap:
            out["fuel_level"] = snap["!FuelLevel"]
        elif "fuel_level" not in out:
